import PrismaInstance from "@lib/prisma";
import { Prisma } from "@prisma/client";
import {
    {{modelName}}CountProps,
    {{modelName}}CountResponse,
    {{modelName}}CreateManyProps,
    {{modelName}}CreateManyResponse,
    {{modelName}}CreateProps,
    {{modelName}}CreateResponse,
    {{modelName}}DeleteManyProps,
    {{modelName}}DeleteManyResponse,
    {{modelName}}DeleteProps,
    {{modelName}}DeleteResponse,
    {{modelName}}FindFirstProps,
    {{modelName}}FindFirstResponse,
    {{modelName}}FindManyProps,
    {{modelName}}FindManyResponse,
    {{modelName}}FindUniqueProps,
    {{modelName}}FindUniqueResponse,
    {{modelName}}UpdateManyProps,
    {{modelName}}UpdateManyResponse,
    {{modelName}}UpdateProps,
    {{modelName}}UpdateResponse,
    {{modelName}}UpsertProps,
    {{modelName}}UpsertResponse,
} from "@services/types";

/**
 * # {{modelName}} Class Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/class/\{{model}}Class.hbs` as base template
 * - to generate class function files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

/**
 * ## {{modelName}} Class
 */
export default class {{modelName}}Service {
    /**
     * ## {{modelName}} Create (Class)
     */
    static async create<T extends Prisma.{{modelName}}CreateArgs>(
        props: {{modelName}}CreateProps<T>,
    ): Promise<{{modelName}}CreateResponse<T>> {
        try {
            return await PrismaInstance.{{modelNameLower}}.create(props);
        } catch (error) {
            throw {{modelName}}Service.error(error);
        }
    }

    /**
     * ## {{modelName}} Upsert (Class)
     */
    static async upsert<T extends Prisma.{{modelName}}UpsertArgs>(
        props: {{modelName}}UpsertProps<T>,
    ): Promise<{{modelName}}UpsertResponse<T>> {
        try {
            return await PrismaInstance.{{modelNameLower}}.upsert(props);
        } catch (error) {
            throw {{modelName}}Service.error(error);
        }
    }

    /**
     * ## {{modelName}} Update (Class)
     */
    static async update<T extends Prisma.{{modelName}}UpdateArgs>(
        props: {{modelName}}UpdateProps<T>,
    ): Promise<{{modelName}}UpdateResponse<T>> {
        try {
            return await PrismaInstance.{{modelNameLower}}.update(props);
        } catch (error) {
            throw {{modelName}}Service.error(error);
        }
    }

    /**
     * ## {{modelName}} Delete (Class)
     */
    static async delete<T extends Prisma.{{modelName}}DeleteArgs>(
        props: {{modelName}}DeleteProps<T>,
    ): Promise<{{modelName}}DeleteResponse<T>> {
        try {
            return await PrismaInstance.{{modelNameLower}}.delete(props);
        } catch (error) {
            throw {{modelName}}Service.error(error);
        }
    }

    /**
     * ## {{modelName}} Create Many (Class)
     */
    static async createMany<T extends Prisma.{{modelName}}CreateManyArgs>(
        props: {{modelName}}CreateManyProps<T>,
    ): Promise<{{modelName}}CreateManyResponse> {
        try {
            return await PrismaInstance.{{modelNameLower}}.createMany(props);
        } catch (error) {
            throw {{modelName}}Service.error(error);
        }
    }

    /**
     * ## {{modelName}} Update Many (Class)
     */
    static async updateMany<T extends Prisma.{{modelName}}UpdateManyArgs>(
        props: {{modelName}}UpdateManyProps<T>,
    ): Promise<{{modelName}}UpdateManyResponse> {
        try {
            return await PrismaInstance.{{modelNameLower}}.updateMany(props);
        } catch (error) {
            throw {{modelName}}Service.error(error);
        }
    }

    /**
     * ## {{modelName}} Delete Many (Class)
     */
    static async deleteMany<T extends Prisma.{{modelName}}DeleteManyArgs>(
        props: {{modelName}}DeleteManyProps<T>,
    ): Promise<{{modelName}}DeleteManyResponse> {
        try {
            return await PrismaInstance.{{modelNameLower}}.deleteMany(props);
        } catch (error) {
            throw {{modelName}}Service.error(error);
        }
    }

    /**
     * ## {{modelName}} Find First (Class)
     */
    static async findFirst<T extends Prisma.{{modelName}}FindFirstArgs>(
        props: {{modelName}}FindFirstProps<T>,
    ): Promise<{{modelName}}FindFirstResponse<T>> {
        try {
            return await PrismaInstance.{{modelNameLower}}.findFirst(props);
        } catch (error) {
            throw {{modelName}}Service.error(error);
        }
    }

    /**
     * ## {{modelName}} Find Unique (Class)
     */
    static async findUnique<T extends Prisma.{{modelName}}FindUniqueArgs>(
        props: {{modelName}}FindUniqueProps<T>,
    ): Promise<{{modelName}}FindUniqueResponse<T>> {
        try {
            return await PrismaInstance.{{modelNameLower}}.findUnique(props);
        } catch (error) {
            throw {{modelName}}Service.error(error);
        }
    }

    /**
     * ## {{modelName}} Find Many (Class)
     */
    static async findMany<T extends Prisma.{{modelName}}FindManyArgs>(
        props: {{modelName}}FindManyProps<T>,
    ): Promise<{{modelName}}FindManyResponse<T>> {
        try {
            return await PrismaInstance.{{modelNameLower}}.findMany(props);
        } catch (error) {
            throw {{modelName}}Service.error(error);
        }
    }

    /**
     * ## {{modelName}} Count (Class)
     */
    static async count<T extends Prisma.{{modelName}}CountArgs>(
        props: {{modelName}}CountProps<T>,
    ): Promise<{{modelName}}CountResponse<T>> {
        try {
            return await PrismaInstance.{{modelNameLower}}.count(props);
        } catch (error) {
            throw {{modelName}}Service.error(error);
        }
    }

    /**
     * ## Error handling (Class)
     */
    private static async error(error: unknown): Promise<{ error: string }> {
        if (process.env.NODE_ENV === "development") {
            const message = (error as Error).message;
            console.error(message);
            throw new Error(message);
        }

        // TODO: add logging
        // await Logging(error);

        // Return safe error message to client
        throw new Error("Something went wrong...");
    }
}
