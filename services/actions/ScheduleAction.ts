"use server";

import ScheduleService from "@class/ScheduleClass";
// import { requiresSafeMessage } from "@permissions/requiresSafeMessage";
import { Prisma } from "@prisma/client";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/library";

/**
 * # Schedule Action Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/actions/{{model}}Action.hbs` as base template
 * - to generate server actions files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ========== Types ========== //

// Create
type ScheduleCreateProps<T extends Prisma.ScheduleCreateArgs> = Prisma.SelectSubset<T, Prisma.ScheduleCreateArgs>;
type ScheduleCreateResponse<T extends Prisma.ScheduleCreateArgs> = GetResult<
    Prisma.$SchedulePayload<InternalArgs>,
    T,
    "create",
    PrismaClientOptions
>;

// Upsert
type ScheduleUpsertProps<T extends Prisma.ScheduleUpsertArgs> = Prisma.SelectSubset<T, Prisma.ScheduleUpsertArgs>;
type ScheduleUpsertResponse<T extends Prisma.ScheduleUpsertArgs> = GetResult<
    Prisma.$SchedulePayload<InternalArgs>,
    T,
    "upsert",
    PrismaClientOptions
>;

// Update
type ScheduleUpdateProps<T extends Prisma.ScheduleUpdateArgs> = Prisma.SelectSubset<T, Prisma.ScheduleUpdateArgs>;
type ScheduleUpdateResponse<T extends Prisma.ScheduleUpdateArgs> = GetResult<
    Prisma.$SchedulePayload<InternalArgs>,
    T,
    "update",
    PrismaClientOptions
>;

// Delete
type ScheduleDeleteProps<T extends Prisma.ScheduleDeleteArgs> = Prisma.SelectSubset<T, Prisma.ScheduleDeleteArgs>;
type ScheduleDeleteResponse<T extends Prisma.ScheduleDeleteArgs> = GetResult<
    Prisma.$SchedulePayload<InternalArgs>,
    T,
    "delete",
    PrismaClientOptions
>;

// Create Many
type ScheduleCreateManyProps<T extends Prisma.ScheduleCreateManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.ScheduleCreateManyArgs
>;
type ScheduleCreateManyResponse = Prisma.BatchPayload;

// Update Many
type ScheduleUpdateManyProps<T extends Prisma.ScheduleUpdateManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.ScheduleUpdateManyArgs
>;
type ScheduleUpdateManyResponse = Prisma.BatchPayload;

// Delete Many
type ScheduleDeleteManyProps<T extends Prisma.ScheduleDeleteManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.ScheduleDeleteManyArgs
>;
type ScheduleDeleteManyResponse = Prisma.BatchPayload;

// Find First
type ScheduleFindFirstProps<T extends Prisma.ScheduleFindFirstArgs> = Prisma.SelectSubset<
    T,
    Prisma.ScheduleFindFirstArgs
>;
type ScheduleFindFirstResponse<T extends Prisma.ScheduleFindFirstArgs> = GetResult<
    Prisma.$SchedulePayload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

// Find Unique
type ScheduleFindUniqueProps<T extends Prisma.ScheduleFindUniqueArgs> = Prisma.SelectSubset<
    T,
    Prisma.ScheduleFindUniqueArgs
>;
type ScheduleFindUniqueResponse<T extends Prisma.ScheduleFindUniqueArgs> = GetResult<
    Prisma.$SchedulePayload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

// Find Many
type ScheduleFindManyProps<T extends Prisma.ScheduleFindManyArgs> = Prisma.SelectSubset<T, Prisma.ScheduleFindManyArgs>;
type ScheduleFindManyResponse<T extends Prisma.ScheduleFindManyArgs> = GetResult<
    Prisma.$SchedulePayload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

// Count
type ScheduleCountProps<T extends Prisma.ScheduleCountArgs> = Prisma.SelectSubset<T, Prisma.ScheduleCountArgs>;
type ScheduleCountResponse<T extends Prisma.ScheduleCountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.ScheduleCountAggregateOutputType>
        : number;

// ========== Services ========== //

/**
 * ## Schedule Create (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ScheduleCreateAction = async <T extends Prisma.ScheduleCreateArgs>(
    props: ScheduleCreateProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ScheduleCreateResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ScheduleCreateAction", "Schedule", "create");
    return await ScheduleService.create(props);
};

/**
 * ## Schedule Upsert (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ScheduleUpsertAction = async <T extends Prisma.ScheduleUpsertArgs>(
    props: ScheduleUpsertProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ScheduleUpsertResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ScheduleUpsertAction", "Schedule", "upsert");
    return await ScheduleService.upsert(props);
};

/**
 * ## Schedule Update (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ScheduleUpdateAction = async <T extends Prisma.ScheduleUpdateArgs>(
    props: ScheduleUpdateProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ScheduleUpdateResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ScheduleUpdateAction", "Schedule", "update");
    return await ScheduleService.update(props);
};

/**
 * ## Schedule Delete (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ScheduleDeleteAction = async <T extends Prisma.ScheduleDeleteArgs>(
    props: ScheduleDeleteProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ScheduleDeleteResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ScheduleDeleteAction", "Schedule", "delete");
    return await ScheduleService.delete(props);
};

/**
 * ## Schedule Create Many (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ScheduleCreateManyAction = async <T extends Prisma.ScheduleCreateManyArgs>(
    props: ScheduleCreateManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ScheduleCreateManyResponse> => {
    // await requiresSafeMessage(disableSafeMessage, "ScheduleCreateManyAction", "Schedule", "createMany");
    return await ScheduleService.createMany(props);
};

/**
 * ## Schedule Update Many (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ScheduleUpdateManyAction = async <T extends Prisma.ScheduleUpdateManyArgs>(
    props: ScheduleUpdateManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ScheduleUpdateManyResponse> => {
    // await requiresSafeMessage(disableSafeMessage, "ScheduleUpdateManyAction", "Schedule", "updateMany");
    return await ScheduleService.updateMany(props);
};

/**
 * ## Schedule Delete Many (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ScheduleDeleteManyAction = async <T extends Prisma.ScheduleDeleteManyArgs>(
    props: ScheduleDeleteManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ScheduleDeleteManyResponse> => {
    // await requiresSafeMessage(disableSafeMessage, "ScheduleDeleteManyAction", "Schedule", "deleteMany");
    return await ScheduleService.deleteMany(props);
};

/**
 * ## Schedule Find First (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const ScheduleFindFirstAction = async <T extends Prisma.ScheduleFindFirstArgs>(
    props: ScheduleFindFirstProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ScheduleFindFirstResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ScheduleFindFirstAction", "Schedule", "findFirst");
    return await ScheduleService.findFirst(props);
};

/**
 * ## Schedule Find Unique (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const ScheduleFindUniqueAction = async <T extends Prisma.ScheduleFindUniqueArgs>(
    props: ScheduleFindUniqueProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ScheduleFindUniqueResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ScheduleFindUniqueAction", "Schedule", "findUnique");
    return await ScheduleService.findUnique(props);
};

/**
 * ## Schedule Find Many (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const ScheduleFindManyAction = async <T extends Prisma.ScheduleFindManyArgs>(
    props: ScheduleFindManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ScheduleFindManyResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ScheduleFindManyAction", "Schedule", "findMany");
    return await ScheduleService.findMany(props);
};

/**
 * ## Schedule Count (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const ScheduleCountAction = async <T extends Prisma.ScheduleCountArgs>(
    props: ScheduleCountProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ScheduleCountResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ScheduleCountAction", "Schedule", "count");
    return await ScheduleService.count(props);
};
