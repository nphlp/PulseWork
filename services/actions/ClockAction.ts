"use server";

import ClockService from "@class/ClockClass";
// import { requiresSafeMessage } from "@permissions/requiresSafeMessage";
import { Prisma } from "@prisma/client";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/library";

/**
 * # Clock Action Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/actions/{{model}}Action.hbs` as base template
 * - to generate server actions files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ========== Types ========== //

// Create
type ClockCreateProps<T extends Prisma.ClockCreateArgs> = Prisma.SelectSubset<T, Prisma.ClockCreateArgs>;
type ClockCreateResponse<T extends Prisma.ClockCreateArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "create",
    PrismaClientOptions
>;

// Upsert
type ClockUpsertProps<T extends Prisma.ClockUpsertArgs> = Prisma.SelectSubset<T, Prisma.ClockUpsertArgs>;
type ClockUpsertResponse<T extends Prisma.ClockUpsertArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "upsert",
    PrismaClientOptions
>;

// Update
type ClockUpdateProps<T extends Prisma.ClockUpdateArgs> = Prisma.SelectSubset<T, Prisma.ClockUpdateArgs>;
type ClockUpdateResponse<T extends Prisma.ClockUpdateArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "update",
    PrismaClientOptions
>;

// Delete
type ClockDeleteProps<T extends Prisma.ClockDeleteArgs> = Prisma.SelectSubset<T, Prisma.ClockDeleteArgs>;
type ClockDeleteResponse<T extends Prisma.ClockDeleteArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "delete",
    PrismaClientOptions
>;

// Create Many
type ClockCreateManyProps<T extends Prisma.ClockCreateManyArgs> = Prisma.SelectSubset<T, Prisma.ClockCreateManyArgs>;
type ClockCreateManyResponse = Prisma.BatchPayload;

// Update Many
type ClockUpdateManyProps<T extends Prisma.ClockUpdateManyArgs> = Prisma.SelectSubset<T, Prisma.ClockUpdateManyArgs>;
type ClockUpdateManyResponse = Prisma.BatchPayload;

// Delete Many
type ClockDeleteManyProps<T extends Prisma.ClockDeleteManyArgs> = Prisma.SelectSubset<T, Prisma.ClockDeleteManyArgs>;
type ClockDeleteManyResponse = Prisma.BatchPayload;

// Find First
type ClockFindFirstProps<T extends Prisma.ClockFindFirstArgs> = Prisma.SelectSubset<T, Prisma.ClockFindFirstArgs>;
type ClockFindFirstResponse<T extends Prisma.ClockFindFirstArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

// Find Unique
type ClockFindUniqueProps<T extends Prisma.ClockFindUniqueArgs> = Prisma.SelectSubset<T, Prisma.ClockFindUniqueArgs>;
type ClockFindUniqueResponse<T extends Prisma.ClockFindUniqueArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

// Find Many
type ClockFindManyProps<T extends Prisma.ClockFindManyArgs> = Prisma.SelectSubset<T, Prisma.ClockFindManyArgs>;
type ClockFindManyResponse<T extends Prisma.ClockFindManyArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

// Count
type ClockCountProps<T extends Prisma.ClockCountArgs> = Prisma.SelectSubset<T, Prisma.ClockCountArgs>;
type ClockCountResponse<T extends Prisma.ClockCountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.ClockCountAggregateOutputType>
        : number;

// ========== Services ========== //

/**
 * ## Clock Create (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ClockCreateAction = async <T extends Prisma.ClockCreateArgs>(
    props: ClockCreateProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ClockCreateResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ClockCreateAction", "Clock", "create");
    return await ClockService.create(props);
};

/**
 * ## Clock Upsert (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ClockUpsertAction = async <T extends Prisma.ClockUpsertArgs>(
    props: ClockUpsertProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ClockUpsertResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ClockUpsertAction", "Clock", "upsert");
    return await ClockService.upsert(props);
};

/**
 * ## Clock Update (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ClockUpdateAction = async <T extends Prisma.ClockUpdateArgs>(
    props: ClockUpdateProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ClockUpdateResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ClockUpdateAction", "Clock", "update");
    return await ClockService.update(props);
};

/**
 * ## Clock Delete (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ClockDeleteAction = async <T extends Prisma.ClockDeleteArgs>(
    props: ClockDeleteProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ClockDeleteResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ClockDeleteAction", "Clock", "delete");
    return await ClockService.delete(props);
};

/**
 * ## Clock Create Many (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ClockCreateManyAction = async <T extends Prisma.ClockCreateManyArgs>(
    props: ClockCreateManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ClockCreateManyResponse> => {
    // await requiresSafeMessage(disableSafeMessage, "ClockCreateManyAction", "Clock", "createMany");
    return await ClockService.createMany(props);
};

/**
 * ## Clock Update Many (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ClockUpdateManyAction = async <T extends Prisma.ClockUpdateManyArgs>(
    props: ClockUpdateManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ClockUpdateManyResponse> => {
    // await requiresSafeMessage(disableSafeMessage, "ClockUpdateManyAction", "Clock", "updateMany");
    return await ClockService.updateMany(props);
};

/**
 * ## Clock Delete Many (Server Action)
 *
 * - optimized for mutations
 * - serial execution without cache
 *
 * **Note**: function generated from template.
 */
export const ClockDeleteManyAction = async <T extends Prisma.ClockDeleteManyArgs>(
    props: ClockDeleteManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ClockDeleteManyResponse> => {
    // await requiresSafeMessage(disableSafeMessage, "ClockDeleteManyAction", "Clock", "deleteMany");
    return await ClockService.deleteMany(props);
};

/**
 * ## Clock Find First (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const ClockFindFirstAction = async <T extends Prisma.ClockFindFirstArgs>(
    props: ClockFindFirstProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ClockFindFirstResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ClockFindFirstAction", "Clock", "findFirst");
    return await ClockService.findFirst(props);
};

/**
 * ## Clock Find Unique (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const ClockFindUniqueAction = async <T extends Prisma.ClockFindUniqueArgs>(
    props: ClockFindUniqueProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ClockFindUniqueResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ClockFindUniqueAction", "Clock", "findUnique");
    return await ClockService.findUnique(props);
};

/**
 * ## Clock Find Many (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const ClockFindManyAction = async <T extends Prisma.ClockFindManyArgs>(
    props: ClockFindManyProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ClockFindManyResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ClockFindManyAction", "Clock", "findMany");
    return await ClockService.findMany(props);
};

/**
 * ## Clock Count (Server Action)
 *
 * **WARNING**: Server actions can't be cached and parallelized
 *
 * - Do not use this for fetching data, use API routes with caching instead
 * - Use it to get fresh data, without any cache
 *
 *  **Note**: function generated from template.
 */
export const ClockCountAction = async <T extends Prisma.ClockCountArgs>(
    props: ClockCountProps<T>,
    // disableSafeMessage: boolean = false,
): Promise<ClockCountResponse<T>> => {
    // await requiresSafeMessage(disableSafeMessage, "ClockCountAction", "Clock", "count");
    return await ClockService.count(props);
};
