import { Prisma } from "@prisma/client";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/library";

/**
 * # Clock Type Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/types/{{model}}Type.hbs` as base template
 * - to generate types files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ============== Utils ============== //

type Payload = Prisma.$ClockPayload<InternalArgs>;

type Flatten<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;

// ============== Model ============== //

/**
 * Clock native fields only
 */
export type ClockModel = Flatten<Payload["scalars"]>;

/**
 * Clock relations fields only
 */
export type ClockRelations = {
    [K in keyof Payload["objects"]]: Payload["objects"][K] extends Array<infer T>
        ? T extends { scalars: unknown }
            ? Flatten<T["scalars"]>[]
            : never
        : Payload["objects"][K] extends { scalars: unknown }
          ? Flatten<Payload["objects"][K]["scalars"]>
          : never;
};

/**
 * Clock native and relations fields
 */
export type ClockComplete = Flatten<ClockModel & ClockRelations>;

/**
 * Clock count type
 */
export type ClockCount = number;

// ========== Types ========== //

/**
 * Clock Create props
 */
export type ClockCreateProps<T extends Prisma.ClockCreateArgs = Prisma.ClockCreateArgs> = Prisma.SelectSubset<
    T,
    Prisma.ClockCreateArgs
>;

/**
 * Clock Create response
 */
export type ClockCreateResponse<T extends Prisma.ClockCreateArgs = Prisma.ClockCreateArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "create",
    PrismaClientOptions
>;

/**
 * Clock Upsert props
 */
export type ClockUpsertProps<T extends Prisma.ClockUpsertArgs = Prisma.ClockUpsertArgs> = Prisma.SelectSubset<
    T,
    Prisma.ClockUpsertArgs
>;

/**
 * Clock Upsert response
 */
export type ClockUpsertResponse<T extends Prisma.ClockUpsertArgs = Prisma.ClockUpsertArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "upsert",
    PrismaClientOptions
>;

/**
 * Clock Update props
 */
export type ClockUpdateProps<T extends Prisma.ClockUpdateArgs = Prisma.ClockUpdateArgs> = Prisma.SelectSubset<
    T,
    Prisma.ClockUpdateArgs
>;

/**
 * Clock Update response
 */
export type ClockUpdateResponse<T extends Prisma.ClockUpdateArgs = Prisma.ClockUpdateArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "update",
    PrismaClientOptions
>;

/**
 * Clock Delete props
 */
export type ClockDeleteProps<T extends Prisma.ClockDeleteArgs = Prisma.ClockDeleteArgs> = Prisma.SelectSubset<
    T,
    Prisma.ClockDeleteArgs
>;

/**
 * Clock Delete response
 */
export type ClockDeleteResponse<T extends Prisma.ClockDeleteArgs = Prisma.ClockDeleteArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "delete",
    PrismaClientOptions
>;

/**
 * Clock Create Many props
 */
export type ClockCreateManyProps<T extends Prisma.ClockCreateManyArgs = Prisma.ClockCreateManyArgs> =
    Prisma.SelectSubset<T, Prisma.ClockCreateManyArgs>;

/**
 * Clock Create Many response
 */
export type ClockCreateManyResponse = Prisma.BatchPayload;

/**
 * Clock Update Many props
 */
export type ClockUpdateManyProps<T extends Prisma.ClockUpdateManyArgs = Prisma.ClockUpdateManyArgs> =
    Prisma.SelectSubset<T, Prisma.ClockUpdateManyArgs>;

/**
 * Clock Update Many response
 */
export type ClockUpdateManyResponse = Prisma.BatchPayload;

/**
 * Clock Delete Many props
 */
export type ClockDeleteManyProps<T extends Prisma.ClockDeleteManyArgs = Prisma.ClockDeleteManyArgs> =
    Prisma.SelectSubset<T, Prisma.ClockDeleteManyArgs>;

/**
 * Clock Delete Many response
 */
export type ClockDeleteManyResponse = Prisma.BatchPayload;

/**
 * Clock Find First props
 */
export type ClockFindFirstProps<T extends Prisma.ClockFindFirstArgs = Prisma.ClockFindFirstArgs> = Prisma.SelectSubset<
    T,
    Prisma.ClockFindFirstArgs
>;

/**
 * Clock Find First response
 */
export type ClockFindFirstResponse<T extends Prisma.ClockFindFirstArgs = Prisma.ClockFindFirstArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

/**
 * Clock Find Unique props
 */
export type ClockFindUniqueProps<T extends Prisma.ClockFindUniqueArgs = Prisma.ClockFindUniqueArgs> =
    Prisma.SelectSubset<T, Prisma.ClockFindUniqueArgs>;

/**
 * Clock Find Unique response
 */
export type ClockFindUniqueResponse<T extends Prisma.ClockFindUniqueArgs = Prisma.ClockFindUniqueArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

/**
 * Clock Find Many props
 */
export type ClockFindManyProps<T extends Prisma.ClockFindManyArgs = Prisma.ClockFindManyArgs> = Prisma.SelectSubset<
    T,
    Prisma.ClockFindManyArgs
>;

/**
 * Clock Find Many response
 */
export type ClockFindManyResponse<T extends Prisma.ClockFindManyArgs = Prisma.ClockFindManyArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

/**
 * Clock Count props
 */
export type ClockCountProps<T extends Prisma.ClockCountArgs = Prisma.ClockCountArgs> = Prisma.SelectSubset<
    T,
    Prisma.ClockCountArgs
>;

/**
 * Clock Count response
 */
export type ClockCountResponse<T extends Prisma.ClockCountArgs = Prisma.ClockCountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.ClockCountAggregateOutputType>
        : number;
