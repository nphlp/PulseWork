import { Prisma } from "@prisma/client";
import { GetResult, InternalArgs, PrismaClientOptions } from "@prisma/client/runtime/library";
import { ClockCountCached, ClockFindFirstCached, ClockFindManyCached, ClockFindUniqueCached } from "@services/cached";
import { ResponseFormat, parseAndDecodeParams } from "@utils/FetchConfig";
import { NextRequest, NextResponse } from "next/server";

/**
 * # Clock Api Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/api/{{model}}Api.hbs` as base template
 * - to generate api function files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

// ========== Types ========== //

// Find First
type ClockFindFirstProps<T extends Prisma.ClockFindFirstArgs> = Prisma.SelectSubset<T, Prisma.ClockFindFirstArgs>;
type ClockFindFirstResponse<T extends Prisma.ClockFindFirstArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "findFirst",
    PrismaClientOptions
>;

// Find Unique
type ClockFindUniqueProps<T extends Prisma.ClockFindUniqueArgs> = Prisma.SelectSubset<T, Prisma.ClockFindUniqueArgs>;
type ClockFindUniqueResponse<T extends Prisma.ClockFindUniqueArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "findUnique",
    PrismaClientOptions
>;

// Find Many
type ClockFindManyProps<T extends Prisma.ClockFindManyArgs> = Prisma.SelectSubset<T, Prisma.ClockFindManyArgs>;
type ClockFindManyResponse<T extends Prisma.ClockFindManyArgs> = GetResult<
    Prisma.$ClockPayload<InternalArgs>,
    T,
    "findMany",
    PrismaClientOptions
>;

// Count
type ClockCountProps<T extends Prisma.ClockCountArgs> = Prisma.SelectSubset<T, Prisma.ClockCountArgs>;
type ClockCountResponse<T extends Prisma.ClockCountArgs> =
    // eslint-disable-next-line
    T extends { select: any }
        ? T["select"] extends true
            ? number
            : Prisma.GetScalarType<T["select"], Prisma.ClockCountAggregateOutputType>
        : number;

// ========== Routes ========== //

type RouteResponse<T> = Promise<NextResponse<ResponseFormat<T>>>;

export type ClockRoutes<Input> = {
    "/internal/clock/findFirst": <T extends Prisma.ClockFindFirstArgs>() => {
        params: ClockFindFirstProps<T>;
        response: ClockFindFirstResponse<Input extends ClockFindFirstProps<T> ? Input : never>;
    };
    "/internal/clock/findUnique": <T extends Prisma.ClockFindUniqueArgs>() => {
        params: ClockFindUniqueProps<T>;
        response: ClockFindUniqueResponse<Input extends ClockFindUniqueProps<T> ? Input : never>;
    };
    "/internal/clock/findMany": <T extends Prisma.ClockFindManyArgs>() => {
        params: ClockFindManyProps<T>;
        response: ClockFindManyResponse<Input extends ClockFindManyProps<T> ? Input : never>;
    };
    "/internal/clock/count": <T extends Prisma.ClockCountArgs>() => {
        params: ClockCountProps<T>;
        response: ClockCountResponse<Input extends ClockCountProps<T> ? Input : never>;
    };
};

// ========== Services ========== //

export const ClockFindFirstApi = async <T extends Prisma.ClockFindFirstArgs>(
    request: NextRequest,
): RouteResponse<ClockFindFirstResponse<T>> => {
    try {
        const params: ClockFindFirstProps<T> = parseAndDecodeParams(request);
        const response: ClockFindFirstResponse<T> = await ClockFindFirstCached(params);
        return NextResponse.json({ data: response }, { status: 200 });
    } catch (error) {
        return NextResponse.json({ error: (error as Error).message }, { status: 500 });
    }
};

export const ClockFindUniqueApi = async <T extends Prisma.ClockFindUniqueArgs>(
    request: NextRequest,
): RouteResponse<ClockFindUniqueResponse<T>> => {
    try {
        const params: ClockFindUniqueProps<T> = parseAndDecodeParams(request);
        const response: ClockFindUniqueResponse<T> = await ClockFindUniqueCached(params);
        return NextResponse.json({ data: response }, { status: 200 });
    } catch (error) {
        return NextResponse.json({ error: (error as Error).message }, { status: 500 });
    }
};

export const ClockFindManyApi = async <T extends Prisma.ClockFindManyArgs>(
    request: NextRequest,
): RouteResponse<ClockFindManyResponse<T>> => {
    try {
        const params: ClockFindManyProps<T> = parseAndDecodeParams(request);
        const response: ClockFindManyResponse<T> = await ClockFindManyCached(params);
        return NextResponse.json({ data: response }, { status: 200 });
    } catch (error) {
        return NextResponse.json({ error: (error as Error).message }, { status: 500 });
    }
};

export const ClockCountApi = async <T extends Prisma.ClockCountArgs>(
    request: NextRequest,
): RouteResponse<ClockCountResponse<T>> => {
    try {
        const params: ClockCountProps<T> = parseAndDecodeParams(request);
        const response: ClockCountResponse<T> = await ClockCountCached(params);
        return NextResponse.json({ data: response }, { status: 200 });
    } catch (error) {
        return NextResponse.json({ error: (error as Error).message }, { status: 500 });
    }
};
