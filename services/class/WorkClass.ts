import PrismaInstance from "@lib/prisma";
import { Prisma } from "@prisma/client";
import {
    WorkCountProps,
    WorkCountResponse,
    WorkCreateManyProps,
    WorkCreateManyResponse,
    WorkCreateProps,
    WorkCreateResponse,
    WorkDeleteManyProps,
    WorkDeleteManyResponse,
    WorkDeleteProps,
    WorkDeleteResponse,
    WorkFindFirstProps,
    WorkFindFirstResponse,
    WorkFindManyProps,
    WorkFindManyResponse,
    WorkFindUniqueProps,
    WorkFindUniqueResponse,
    WorkUpdateManyProps,
    WorkUpdateManyResponse,
    WorkUpdateProps,
    WorkUpdateResponse,
    WorkUpsertProps,
    WorkUpsertResponse,
} from "@services/types";

/**
 * # Work Class Services
 *
 * This file:
 * - is generated by the command `pnpm run generate:all`
 * - that executes the script: `scripts/generator.ts`
 * - which uses `template/services/class/{{model}}Class.hbs` as base template
 * - to generate class function files for every models available in the `prisma/client/index.d.ts`.
 *
 * > **Warning**: Do not edit this file directly. Your changes will be lost the next time the code is generated.
 */

/**
 * ## Work Class
 */
export default class WorkService {
    /**
     * ## Work Create (Class)
     */
    static async create<T extends Prisma.WorkCreateArgs>(props: WorkCreateProps<T>): Promise<WorkCreateResponse<T>> {
        try {
            return await PrismaInstance.work.create(props);
        } catch (error) {
            throw WorkService.error(error);
        }
    }

    /**
     * ## Work Upsert (Class)
     */
    static async upsert<T extends Prisma.WorkUpsertArgs>(props: WorkUpsertProps<T>): Promise<WorkUpsertResponse<T>> {
        try {
            return await PrismaInstance.work.upsert(props);
        } catch (error) {
            throw WorkService.error(error);
        }
    }

    /**
     * ## Work Update (Class)
     */
    static async update<T extends Prisma.WorkUpdateArgs>(props: WorkUpdateProps<T>): Promise<WorkUpdateResponse<T>> {
        try {
            return await PrismaInstance.work.update(props);
        } catch (error) {
            throw WorkService.error(error);
        }
    }

    /**
     * ## Work Delete (Class)
     */
    static async delete<T extends Prisma.WorkDeleteArgs>(props: WorkDeleteProps<T>): Promise<WorkDeleteResponse<T>> {
        try {
            return await PrismaInstance.work.delete(props);
        } catch (error) {
            throw WorkService.error(error);
        }
    }

    /**
     * ## Work Create Many (Class)
     */
    static async createMany<T extends Prisma.WorkCreateManyArgs>(
        props: WorkCreateManyProps<T>,
    ): Promise<WorkCreateManyResponse> {
        try {
            return await PrismaInstance.work.createMany(props);
        } catch (error) {
            throw WorkService.error(error);
        }
    }

    /**
     * ## Work Update Many (Class)
     */
    static async updateMany<T extends Prisma.WorkUpdateManyArgs>(
        props: WorkUpdateManyProps<T>,
    ): Promise<WorkUpdateManyResponse> {
        try {
            return await PrismaInstance.work.updateMany(props);
        } catch (error) {
            throw WorkService.error(error);
        }
    }

    /**
     * ## Work Delete Many (Class)
     */
    static async deleteMany<T extends Prisma.WorkDeleteManyArgs>(
        props: WorkDeleteManyProps<T>,
    ): Promise<WorkDeleteManyResponse> {
        try {
            return await PrismaInstance.work.deleteMany(props);
        } catch (error) {
            throw WorkService.error(error);
        }
    }

    /**
     * ## Work Find First (Class)
     */
    static async findFirst<T extends Prisma.WorkFindFirstArgs>(
        props: WorkFindFirstProps<T>,
    ): Promise<WorkFindFirstResponse<T>> {
        try {
            return await PrismaInstance.work.findFirst(props);
        } catch (error) {
            throw WorkService.error(error);
        }
    }

    /**
     * ## Work Find Unique (Class)
     */
    static async findUnique<T extends Prisma.WorkFindUniqueArgs>(
        props: WorkFindUniqueProps<T>,
    ): Promise<WorkFindUniqueResponse<T>> {
        try {
            return await PrismaInstance.work.findUnique(props);
        } catch (error) {
            throw WorkService.error(error);
        }
    }

    /**
     * ## Work Find Many (Class)
     */
    static async findMany<T extends Prisma.WorkFindManyArgs>(
        props: WorkFindManyProps<T>,
    ): Promise<WorkFindManyResponse<T>> {
        try {
            return await PrismaInstance.work.findMany(props);
        } catch (error) {
            throw WorkService.error(error);
        }
    }

    /**
     * ## Work Count (Class)
     */
    static async count<T extends Prisma.WorkCountArgs>(props: WorkCountProps<T>): Promise<WorkCountResponse<T>> {
        try {
            return await PrismaInstance.work.count(props);
        } catch (error) {
            throw WorkService.error(error);
        }
    }

    /**
     * ## Error handling (Class)
     */
    private static async error(error: unknown): Promise<{ error: string }> {
        if (process.env.NODE_ENV === "development") {
            const message = (error as Error).message;
            console.error(message);
            throw new Error(message);
        }

        // TODO: add logging
        // await Logging(error);

        // Return safe error message to client
        throw new Error("Something went wrong...");
    }
}
